"""
    biclustlib: A Python library of biclustering algorithms and evaluation measures.
    Copyright (C) 2017  Victor Alexandre Padilha

    This file is part of biclustlib.

    biclustlib is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    biclustlib is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
import shutil
import subprocess
import tempfile
from abc import ABCMeta, abstractmethod
from time import sleep

import numpy as np
import rpy2.robjects as robjs
import rpy2.robjects.numpy2ri
from rpy2.rinterface_lib.embedded import RRuntimeError
from sklearn.utils.validation import check_array

from .._base import BaseBiclusteringAlgorithm
from ...models import Bicluster, Biclustering

rpy2.robjects.numpy2ri.activate()


class ExecutableWrapper(BaseBiclusteringAlgorithm, metaclass=ABCMeta):
    """This class defines the skeleton of a naive executable wrapper. In summary,
    in every execution, it will create a temporary directory, save the input data
    as a txt file, run the wrapped algorithm, parse the output files and remove the
    temporary directory.

    Parameters
    ----------
    exec_comm : str
        The command line command to run the wrapped executable.

    tmp_dir : str
        Temporary directory path, where temporary files will be stored.

    sleep : bool, default: True
        Whether to make a 1 second delay before running the wrapped executable.

    data_type : numpy.dtype, default: numpy.double
        The input data type required by the algorithm.
    """

    def __init__(self, data_filename='data.txt', output_filename='output.txt', data_type=np.double, sleep=1):
        super().__init__()

        self._data_filename = data_filename
        self._output_filename = output_filename
        self._data_type = data_type
        self._sleep = sleep

    def run(self, data):
        """Compute biclustering.

        Parameters
        ----------
        data : numpy.ndarray
        """
        self._validate_parameters()
        data = check_array(data, dtype=self._data_type, copy=True)

        tmp_dir = tempfile.mkdtemp()

        data_path = os.path.join(tmp_dir, self._data_filename)
        output_path = os.path.join(tmp_dir, self._output_filename)

        self._write_data(data_path, data)
        sleep(self._sleep)
        comm = self._get_command(data, data_path, output_path).split()

        try:
            subprocess.check_call(comm, stderr=subprocess.STDOUT)
            biclustering = self._parse_output(output_path)

        except subprocess.CalledProcessError as error:
            print('The following error occurred while running the command {}:\n{}'.format(comm, error.output))
            print('Returning empty biclustering solution.')
            biclustering = Biclustering([])

        shutil.rmtree(tmp_dir)

        return biclustering

    @abstractmethod
    def _get_command(self, data, data_path, output_path):
        pass

    @abstractmethod
    def _write_data(self, data_path, data):
        """Write input data to txt file."""
        pass

    @abstractmethod
    def _parse_output(self, output_path):
        """Parses the output file generated by the wrapped executable."""
        pass


class SklearnWrapper(BaseBiclusteringAlgorithm, metaclass=ABCMeta):
    """This class defines the skeleton of a wrapper for the scikit-learn
    package.
    """

    def __init__(self, constructor, **kwargs):
        self.wrapped_algorithm = constructor(**kwargs)

    def run(self, data):
        """Compute biclustering.

        Parameters
        ----------
        data : numpy.ndarray
        """
        self.wrapped_algorithm.fit(data)

        biclusters = []

        for rows, cols in zip(*self.wrapped_algorithm.biclusters_):
            b = self._get_bicluster(rows, cols)
            biclusters.append(b)

        return Biclustering(biclusters)

    def _get_bicluster(self, rows, cols):
        return Bicluster(rows, cols)


class RBiclustWrapper(BaseBiclusteringAlgorithm, metaclass=ABCMeta):

    def __init__(self, data_type=np.double):
        super().__init__()
        self._data_type = data_type
        self._r_lib = 'biclust'
        self._r_func = 'biclust'

    def run(self, data):
        self._validate_parameters()
        params = self._get_parameters()
        data = check_array(data, dtype=self._data_type, copy=True)

        try:
            robjs.r.library(self._r_lib)
            biclust_func = robjs.r[self._r_func]
            biclust_result = biclust_func(data, **params)
            biclustering = self._get_biclustering(data, biclust_result)

        except RRuntimeError as error:
            print('The following error occurred while running R:\n' + str(error))
            print('Returning empty biclustering solution.')
            biclustering = Biclustering([])

        return biclustering

    def _get_biclustering(self, data, biclust_result):
        biclusters = []
        number = int(biclust_result.do_slot('Number')[0])

        if number:
            rows_bool = np.array(biclust_result.do_slot('RowxNumber'), np.bool).T
            cols_bool = np.array(biclust_result.do_slot('NumberxCol'), np.bool)

            if cols_bool.shape[0] == data.shape[1]:
                cols_bool = cols_bool.T

            for rows, cols in zip(rows_bool, cols_bool):
                rows = np.nonzero(rows)[0]
                cols = np.nonzero(cols)[0]

                if len(rows) and len(cols):
                    biclusters.append(Bicluster(rows, cols))

        return Biclustering(biclusters)

    @abstractmethod
    def _get_parameters(self):
        pass
